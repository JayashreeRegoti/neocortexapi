////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2015 Frankfurt University of Applied Sciences / daenet GmbH
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following
// conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
////////////////////////////////////////////////////////////////////////////////////////////////

using NeoCortexApi.Entities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;

namespace NeoCortexApi.Utility
{

    /**
     * <p>
     * Allegory to the Python itertools.groupby. Objects of this class
     * take a list of inputs and a function to produce keys. The iterator
     * or foreach loop generates grouped return values based on the key
     * generated by the supplied function.<br>
     * For instance:<br>
     * <pre>
     * Given the list:
     * List<Integer> l = Arrays.asList(new Integer[] { 2, 4, 4, 5 });
     * and the function:
     * Function<Integer, Integer> lambda = x -> x * 3;
     * 
     * A GroupBy can be compose as such:
     * GroupBy<Integer, Integer> grouper = GroupBy.of(l, lambda);
     * 
     * ...then iterated over as such:
     * for(Pair<Integer, Integer> p : grouper) {
     *     System.out.println("Pair key: " + p.getKey() + ", pair value: " + p.getValue());
     * }
     * 
     * Outputs:
     * 
     * Pair key: 2, pair value: 6
     * Pair key: 4, pair value: 12
     * Pair key: 4, pair value: 12
     * Pair key: 5, pair value: 15
     * </p>
     * <p>
     * Notes: Read up on groupby here:
     *        https://docs.python.org/dev/library/itertools.html#itertools.groupby
     *        
     * </p>
     * @author cogmission
     *
     * @param <T>
     * @param <R>
     */
    public class GroupBy<T, R> : IEnumerable<Pair<T, R>>, IEnumerator<Pair<T, R>>
    {

        /** serial version */
        //private static readonly long serialVersionUID = 1L;

        private bool m_IsStarted;

        private List<T> m_ElementList;
        private Func<T, R> m_Func;
        private IntGenerator m_IntegerGenerator;
        private Pair<T, R> m_CurrentElement;


        public Pair<T, R> Current => this.m_CurrentElement;

        object IEnumerator.Current => this.m_CurrentElement;


        #region Constructors and Initialization


        /**
         * Constructs a new {@code GroupBy}
         * 
         * @param l     the {@link List} containing the items used as input to the
         *              key generating function.     
         * @param fn    the {@link Function} to be used to generate the keys which describe
         *              the like contents of each grouping.
         */
        public GroupBy(List<T> l, Func<T, R> func)
        {
            this.m_ElementList = l;
            this.m_Func = func;
            this.m_IntegerGenerator = IntGenerator.of(0, m_ElementList.Count);

            if (m_IntegerGenerator.hasNext())
            {
                T t = m_ElementList[m_IntegerGenerator.get()];
                m_IsStarted = false;
                m_CurrentElement = new Pair<T, R>(t, func(t));
            }
        }


        /**
         * Returns a new {@code GroupBy} composed from the specified list 
         * and key-generating {@link Function}
         * 
         * @param l     the {@link List} containing the items used as input to the
         *              key generating function.     
         * @param fn    the {@link Function} to be used to generate the keys which describe
         *              the like contents of each grouping.
         * @return
         */
        public static GroupBy<T, R> From(List<T> l, Func<T, R> fn)
        {
            return new GroupBy<T, R>(l, fn);
        }
        #endregion


        /**
         * {@inheritDoc}
         */
        // @Override

        [Obsolete("Use .Current instead")]
        public Pair<T, R> peek()
        {
            return m_CurrentElement;
        }

        /**
         * {@inheritDoc}
         */
        // @Override
        //public bool hasNext()
        //{
        //    return m_CurrentElement != null;
        //}


        /// <summary>
        /// Moves to the nex pair.
        /// </summary>
        /// <returns></returns>
        public bool MoveNext()
        {
            Pair<T, R> ret = m_CurrentElement;

            if (m_IntegerGenerator.hasNext())
            {
                T t;

                if (m_IsStarted)
                {
                    m_IntegerGenerator.next();
                }
                else
                {                   
                    m_IsStarted = true;
                }

                t = m_ElementList[m_IntegerGenerator.get()];

                m_CurrentElement = new Pair<T, R>(t, m_Func(t));

                return true;
            }
            else
            {
                m_CurrentElement = null;
                return false;
            }
        }

        /// <summary>
        /// Shows the next pair, but it does not move internal pointer to it.
        /// </summary>
        /// <returns></returns>
        public Pair<T, R> NextPair
        {
            get
            {
                Pair<T, R> ret;

                if (m_IntegerGenerator.hasNext())
                {
                    var nextVal = m_IntegerGenerator.NextValue;

                    T t = m_ElementList[nextVal];

                    ret = new Pair<T, R>(t, m_Func(t));
                }
                else
                {
                    ret = null;
                }

                return ret;
            }
        }

        public void Reset()
        {
            m_IntegerGenerator.reset();
            m_IntegerGenerator.next();
            m_CurrentElement = null;
            m_IsStarted = false;
        }

        public void Dispose()
        {

        }

        public IEnumerator<Pair<T, R>> GetEnumerator()
        {
            return this;
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return this;
        }
    }

}
